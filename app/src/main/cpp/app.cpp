/*
 * This source file was generated by the Gradle 'init' task
 */

#include <queue>
#include <memory>
#include <ctime>
#include <limits>
#include <algorithm>
#include "Patient.h"
#include "PatientRecord.h"
#include "app.h"
#include "IntakeForm.h"
#include "DischargeForm.h"

struct Bed {
    bool available = true;
    std::shared_ptr<PatientRecord> patientRecord = nullptr;
}; 

void displayQueue(std::priority_queue<PatientRecord, std::vector<PatientRecord>, PatientComparator> q) {
    std::cout << "\nðŸ“‹ Current Queue (Highest Priority First):\n";
    while (!q.empty()) {
        auto p = q.top().patient;
        p->displayInfo();
        q.pop();
    }
    std::cout << "------------------------------\n";
}

std::string toLower(const std::string& str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(), ::tolower);
    return result;  
}

void removePatient(std::priority_queue<PatientRecord, std::vector<PatientRecord>, PatientComparator> queue, const std::string& target) {
    std::priority_queue<PatientRecord, std::vector<PatientRecord>, PatientComparator> newQueue;
    bool found = false;


    while (!queue.empty()) {
        PatientRecord record = queue.top();
        queue.pop();

        if (toLower(record.patient->getName()) == toLower(target)) {
            found = true;
            std::cout << "Removed Patient: " << target << "\n";
            continue;
        }

        newQueue.push(record);
    }
    
    if (!found) {
        std::cout << "Patient not found in queue.\n";
    }

    queue = std::move(newQueue);
}

std::shared_ptr<PatientRecord> getPatientToDischarge(std::array<Bed, 30>& bedsAvailable, std::string patientName) {

    for (Bed& bed : bedsAvailable) {
        if (bed.patientRecord && toLower(bed.patientRecord->patient->getName()) == toLower(patientName)) {
            auto patient = bed.patientRecord->patient;
            bed.patientRecord = nullptr;
            bed.available = false;
            return std::make_shared<PatientRecord>(bed.patientRecord);
        }
    }
    
    std::cout << "\nPatient not found.\n";
    return nullptr;
}


int main () {
    std::priority_queue<
        PatientRecord,
        std::vector<PatientRecord>,
        PatientComparator
    > erQueue;



    std::array<Bed, 30> bedsAvailable;

    IntakeForm form;
    std::string action;
    int openBed = 0;


    char more = 'y';
    while(true) {
        std::cout << "What would you like to do?\nTo add patient type 'add'\nTo remove patient from queue type 'remove\nTo discharge patient type 'discharge.'" << std::endl;
        std::getline(std::cin, action);

        if (action == "add") {
            auto patient = form.collect();
            PatientRecord record(std::time(nullptr), patient);

            if (openBed < 30) {
                bedsAvailable[openBed].available = false;
                bedsAvailable[openBed].patientRecord = std::make_shared<PatientRecord>(record);
                openBed++;
            } else {
                erQueue.push(record);
                displayQueue(erQueue);
            }
        } else if (action == "remove") {
            std::string target;
            std::cout << "Which patient would you like to remove? Enter name: ";
            std::getline(std::cin, target);
            removePatient(erQueue, target);
        } else if (action == "discharge") {
            std::string patientToDischarge;
            std::cout << "Which patient do you want to discharge? Enter name: \n";
            std::getline(std::cin, patientToDischarge);
            std::shared_ptr<PatientRecord> dischargedPatient = (getPatientToDischarge(bedsAvailable, patientToDischarge));

            DischargeForm form;
            // form.dischargePatient(dischargedPatient);

        } else {
            std::cout << "Please enter a valid option.\n" << std::endl;
        }






        std::string line;
        std::cout << "Add another patient? (y/n): ";
        std::getline(std::cin, line);

        if (!line.empty()) {
            more = line[0];
        } else {
            more = 'n';
        }

        if (more != 'y' && more != 'Y') {
            break;
        }
    }

    return 0;
}
