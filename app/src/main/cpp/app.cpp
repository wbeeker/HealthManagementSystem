/*
 * This source file was generated by the Gradle 'init' task
 */

#include <queue>
#include <memory>
#include <ctime>
#include <limits>
#include <algorithm>
#include "Patient.h"
#include "PatientRecord.h"
#include "app.h"
#include "IntakeForm.h"
#include "DischargeForm.h"

// Creates an emergency room Bed object to track availability and which patient is currently in the bed if occupied.
struct Bed {
    bool available = true;
    std::shared_ptr<PatientRecord> patientRecord = nullptr;
    std::time_t dischargeTime = 0;
}; 

struct BedIndexComparator {
    const std::array<Bed, 30> beds;

    BedIndexComparator(const std::array<Bed, 30>& ref) : beds(ref) {}

    bool operator()(int i, int j) const {
        return beds[i].dischargeTime > beds[j].dischargeTime;
    }
};

// Main list of available beds.
std::array<Bed, 30> bedsAvailable;

BedIndexComparator comp(bedsAvailable);

// Creates queue of available beds ordered by longest time empty. 
std::priority_queue<
    int,
    std::vector<int>,
    BedIndexComparator
> bedsQueue(comp);

// Prints the current waiting queue in the console.
void displayQueue(std::priority_queue<PatientRecord, std::vector<PatientRecord>, PatientComparator> q) {
    std::cout << "\nðŸ“‹ Current Queue (Highest Priority First):\n";
    while (!q.empty()) {
        auto p = q.top().patient;
        p->displayInfo();
        q.pop();
    }
    std::cout << "------------------------------\n";
}

//A helper function to turn strings to lowercase.
std::string toLower(const std::string& str) {
    std::string result = str;
    std::transform(result.begin(), result.end(), result.begin(), ::tolower);
    return result;  
}

// Removes a patient from the waiting queue by rebuilding the queue without the selected patient. (Note: removals should be rare.)
void removePatient(std::priority_queue<PatientRecord, std::vector<PatientRecord>, PatientComparator> queue, const std::string& target) {
    std::priority_queue<PatientRecord, std::vector<PatientRecord>, PatientComparator> newQueue;
    bool found = false;


    while (!queue.empty()) {
        PatientRecord record = queue.top();
        queue.pop();

        if (toLower(record.patient->getName()) == toLower(target)) {
            found = true;
            std::cout << "Removed Patient: " << target << "\n";
            continue;
        }

        newQueue.push(record);
    }
    
    if (!found) {
        std::cout << "Patient not found in queue.\n";
    }

    queue = std::move(newQueue);
}

// Fetches the patient to discharge from the list of Beds. Changes his bed to available. 
std::shared_ptr<PatientRecord> getPatientToDischarge(std::array<Bed, 30>& bedsAvailable, std::string patientName) {

    for (int i = 0; i < bedsAvailable.size(); ++i) {
        Bed& bed = bedsAvailable[i];
        if (bed.patientRecord && toLower(bed.patientRecord->patient->getName()) == toLower(patientName)) {
            auto patientRecord = bed.patientRecord;
            bed.patientRecord = nullptr;
            bed.available = false;
            bed.dischargeTime = std::time(nullptr);
            bedsQueue.push(i);
            return patientRecord;
        }
    }
    
    std::cout << "\nPatient not found.\n";
    return nullptr;
}


int main () {

    // Initializes bed list and empty beds queue.
    std::time_t now = std::time(nullptr);
    for (int i = 0; i < bedsAvailable.size(); ++i) {
        bedsAvailable[i].dischargeTime = now;
        bedsQueue.push(i);
    }

    // Creates waiting queue. 
    std::priority_queue<
        PatientRecord,
        std::vector<PatientRecord>,
        PatientComparator
    > erQueue;

    IntakeForm form;
    std::string action;

    // Main loop to prompt user to perform an action. 
    while(true) {
        std::cout << "What would you like to do?\nTo add patient type 'add'\nTo remove patient from queue type 'remove\nTo discharge patient type 'discharge.'" << std::endl;
        std::getline(std::cin, action);

        if (action == "add") {
            auto patient = form.collect();
            PatientRecord record(std::time(nullptr), patient);

            if (openBed < 30) {
                bedsAvailable[openBed].available = false;
                bedsAvailable[openBed].patientRecord = std::make_shared<PatientRecord>(record);
                openBed++;
            } else {
                erQueue.push(record);
                displayQueue(erQueue);
            }
        } else if (action == "remove") {
            std::string target;
            std::cout << "Which patient would you like to remove? Enter name: ";
            std::getline(std::cin, target);
            removePatient(erQueue, target);
        } else if (action == "discharge") {
            std::string patientToDischarge;
            std::cout << "Which patient do you want to discharge? Enter name: \n";
            std::getline(std::cin, patientToDischarge);
            std::shared_ptr<PatientRecord> dischargedPatient = (getPatientToDischarge(bedsAvailable, patientToDischarge));

            if (dischargedPatient) {
                DischargeForm form;
                form.dischargePatient(*dischargedPatient);
            } else {
                std::cout << "Discharge failed: Patient not found.\n";
            }

        } else {
            std::cout << "Please enter a valid option.\n" << std::endl;
        }

        std::string line;
        std::cout << "Would you like to perform another action? (y/n): ";
        std::getline(std::cin, line);

        if ((line[0]) == 'n' || line[0] == 'N') {
            std::cout << "Thanks for using Health Management System. Bye!\n" << std::endl;
            break;
        }
    }

    return 0;
}
